{"pageProps":{"post":{"localPath":"/home/f440/go/src/github.com/f440/f440.github.com/content/2013-06-17-docker.markdown","path":"2013/06/17/docker","layout":"post","title":"仮想環境構築に docker を使う","createdAt":"2013-06-17T00:13:00.000Z","kind":"article","comments":true,"tags":["docker","lxc"],"content":"<p>ちょっと前から <a href=\"http://www.docker.io/\">Docker</a> を使っているので、その話。</p>\n<!-- more -->\n<h2>Dockr について</h2>\n<p><a href=\"http://www.docker.io/\">Docker</a> は <a href=\"https://www.dotcloud.com/\">dotcloud</a> がオープンソースで公開している、コンテナ技術による仮想化ソフトウェア。</p>\n<p>以下のテクノロジーベースにしている:</p>\n<ul>\n<li><a href=\"http://lxc.sourceforge.net/\">LXC</a>\n<ul>\n<li><a href=\"/blog/2012/05/13/vps-lxc-xtradb-cluster/\">前にも書いた</a>。Xen とか VirtualBOX みたいにホスト内に仮想マシンを立ち上げるんじゃなくて、ホスト内の隔離された環境で仮想マシンを動かす技術。物理マシンをシミュレーションしているんじゃないってことは、VPS とか EC2 とかの仮想マシン上でも問題なく動くし、マシンを起動するプロセスが不要となるので、一瞬で使い始められるというメリットにつながっている。</li>\n</ul>\n</li>\n<li><a href=\"http://aufs.sourceforge.net/\">AUFS</a>\n<ul>\n<li>UnionFS(ディレクトリを重ね合わせることができる)の実装の一つ。元の仮想マシンイメージを書き換えないで、更新が発生した部分は別の場所に書き込んでいくようになっている。これにより、仮想マシンの立ち上げ時にイメージのコピーが発生しないので、すぐに使い始められる。</li>\n</ul>\n</li>\n</ul>\n<p>Docker を使う前は LXC のラッパーとして取っつきにくさを緩和してくれる、とかそういうレベルだと思ったんだけど、予想はよい方向に裏切られた。</p>\n<p><a href=\"http://docs.docker.io/en/latest/commandline/command/images/\">仮想マシンのイメージを可視化したもの</a>を見ると、まるで Git のコミットログみたいに見えると思う。実際、情報は差分で管理され、履歴を残したり分岐させたりといった操作が非常に軽量にできていて、Git を操作するかのように仮想マシンを操作できるようになっている。</p>\n<h2>動かし方</h2>\n<p>Arch Linux や Debian で動かしている人がいるみたいだけど、公式サポートは今のところ Ubuntu のみ。Ubuntu 12.04 LTS を使っているのであれば、<code>curl get.docker.io | sh -x</code> で動くようになる。</p>\n<p>ちゃんとしたやり方は <a href=\"http://docs.docker.io/en/latest/installation/\">ドキュメント</a>を見れば、特にはまることもないと思う。できるだけ新しい Ubuntu を使っておけばいい。</p>\n<p>すぐに試してみたいんなら、Vagrant 経由で簡単に使い始められる。</p>\n<pre><code>git clone https://github.com/dotcloud/docker.git\ncd docker\nvagrant up --provider virtualbox # or vagrant up --provider aws\n</code></pre>\n<h2>基礎的な操作方法</h2>\n<p>インストールがうまくいって Docker が起動しているものとして、早速使ってみる。</p>\n<pre><code>$ docker\nUsage: docker [OPTIONS] COMMAND [arg...]\n  -H=\"127.0.0.1:4243\": Host:port to bind/connect to\n\n  A self-sufficient runtime for linux containers.\n\n  Commands:\n  attach    Attach to a running container\n  build     Build a container from a Dockerfile\n  commit    Create a new image from a container's changes\n(以下省略)\n</code></pre>\n<p>コマンドがずらっと表示されるかと思う。まずは単発のコマンドをコンテナ内で実行してみる。</p>\n<pre><code>$ docker run base /bin/echo hi\nPulling repository base from https://index.docker.io/v1\nPulling image b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc (latest) from base\nPulling b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc metadata\nPulling b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc fs layer\nDownloading 10240/? (n/a)\nPulling 27cf784147099545 metadata\nPulling 27cf784147099545 fs layer\nDownloading 94863360/? (n/a)\nPulling image 27cf784147099545 () from base\nhi\n</code></pre>\n<p>「<code>docker</code> コマンドに run サブコマンドを指定して、<code>base</code> という仮想マシンで <code>/bin/echo hi</code> コマンドを実行する」という意味になる。仮想マシンがダウンロードされるが、これは初回実行時のみ。最後に表示された「hi」というのが今回の実行結果で、このコンテナの役割はこれで終わり。</p>\n<p>今度は作ったマシンの中に入ってみるために、<code>-i</code> と <code>-t</code> オプションで入出力できるようにして <code>/bin/bash</code> を起動してみる。</p>\n<pre><code>$ docker run -i -t base /bin/bash\nroot@bc43a290f0ce:/#\n</code></pre>\n<p>端末から抜けるとホスト側に制御が戻る。</p>\n<pre><code>root@bc43a290f0ce:/# exit\nexit\n$\n</code></pre>\n<p>今度は <code>-d</code> オプションでコマンドを実行しっぱなしにする。</p>\n<pre><code>$ docker run -i -t -d base /bin/ping -i 5 www.aikatsu.net\n79365b2985c4\n$\n</code></pre>\n<p>ID が返されて、すぐに端末が利用可能になる。稼働中のプロセスを確認してみる。</p>\n<pre><code>$ docker ps\nID                  IMAGE               COMMAND                CREATED             STATUS              PORTS\n79365b2985c4        base:latest         /bin/ping -i 5 www.a   22 seconds ago      Up 21 seconds\n</code></pre>\n<p>次に実行中の出力をのぞいてみよう。</p>\n<pre><code>$ docker logs 79365b2985c4\nPING www.aikatsu.net (60.32.7.37) 56(84) bytes of data.\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=1 ttl=49 time=282 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=3 ttl=49 time=278 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=4 ttl=49 time=283 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=5 ttl=49 time=266 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=6 ttl=49 time=268 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=8 ttl=49 time=264 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=9 ttl=49 time=270 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=10 ttl=49 time=290 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=11 ttl=49 time=284 ms\n</code></pre>\n<p>順調に動き続けているようなので、このジョブにアタッチしてみる。</p>\n<pre><code>$ docker attach 79365b2985c4\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=18 ttl=49 time=239 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=19 ttl=49 time=291 ms\n64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=20 ttl=49 time=275 ms\n(出力が続く)\n</code></pre>\n<p>アタッチ中の端末は <code>Ctrl-p Ctrl-q</code> でデタッチできる。(このとき use of closed network connection っていうエラーが出る場合 Ctrl-c で抜けるしかないっぽい。バグレポートは上がっているので、じきに直ると思う。)</p>\n<p>最後に<code>kill</code>でこのプロセスを消してみる。</p>\n<pre><code>$ docker kill 79365b2985c4\n$ docker ps\n$\n</code></pre>\n<p><code>ps</code>からプロセスが消えた。基礎的なコンテナの操作の説明は以上。</p>\n<h2>詳細</h2>\n<h3>コンテナ</h3>\n<p>これまでコマンドを実行したり、<code>kill</code> されたコンテナはどうなっているのか。実は全部残っている。停止したコンテナを表示するために<code>-a</code>をつける。ついでに、情報を省略しないで表示するために<code>-notrunc</code> もつける。</p>\n<pre><code>$ docker ps -a -notrunc\nID                                                                 IMAGE               COMMAND                          CREATED             STATUS              PORTS\n79365b2985c43a2a6977764f4dde2d375084020fbc04cc855508c417a36f88c2   base:latest         /bin/ping -i 5 www.aikatsu.net   14 minutes ago      Exit 0\nbc43a290f0ced4677ee7eb1a0d662cca496cc720d8db20e746dda45e4659f503   base:latest         /bin/bash                        16 minutes ago      Exit 0\n7a666192cca72cea81cade398b22700c982fbb9271a7eca23ff51c6c504d5971   base:latest         /bin/echo hi                     16 minutes ago      Exit 0\n8b0af4fc390d762c33dadc1b149516ba95bdb70d093e991ec2df563817f55ffb   base:latest         /bin/bash                        21 minutes ago      Exit 0\n4637bc6341706c25e066c5ccfe92e10c923bfe4955a9e8b3ce07237fda0fb34a   base:latest         /bin/echo hi                     21 minutes ago      Exit 0\n</code></pre>\n<p>正常終了しているので、すべて<code>Exit 0</code>になっている。また、ID は省略表記されていたこともわかる。コンテナの実体は <code>/var/lib/docker/containers/&#x3C;ID></code> 以下に格納されている。</p>\n<pre><code>$ sudo ls /var/lib/docker/containers/\n4637bc6341706c25e066c5ccfe92e10c923bfe4955a9e8b3ce07237fda0fb34a\n79365b2985c43a2a6977764f4dde2d375084020fbc04cc855508c417a36f88c2\n7a666192cca72cea81cade398b22700c982fbb9271a7eca23ff51c6c504d5971\n8b0af4fc390d762c33dadc1b149516ba95bdb70d093e991ec2df563817f55ffb\nbc43a290f0ced4677ee7eb1a0d662cca496cc720d8db20e746dda45e4659f503\n</code></pre>\n<p>どんどんたまっていくから心配かもしれないけど、各コンテナはベースイメージからの差分しかもたないので、問題にならない。もし、消したくなったら <code>docker rm &#x3C;コンテナのID></code> で消せる。</p>\n<p>作業領域であったコンテナを <code>commit</code> するとイメージとして使い回せるようになる。<code>ユーザー名/名称</code>にするのが作法っぽい。</p>\n<pre><code>$ docker commit -m \"My first container\" 4637bc634170 f440/first_container\n02036952e5dc\n$ docker images\nREPOSITORY             TAG                 ID                  CREATED\nbase                   latest              b750fe79269d        12 weeks ago\nbase                   ubuntu-quantl       b750fe79269d        12 weeks ago\nbase                   ubuntu-quantal      b750fe79269d        12 weeks ago\nbase                   ubuntu-12.10        b750fe79269d        12 weeks ago\nf440/first_container   latest              02036952e5dc        3 seconds ago\n</code></pre>\n<p>これで今後は <code>docker run f440/first_container</code> をベースにしたコンテナを作れるようになる。</p>\n<h3>イメージ</h3>\n<p>もう一回イメージの一覧を内容を確認してみよう。</p>\n<pre><code>$ docker images\nREPOSITORY             TAG                 ID                  CREATED\nf440/first-container   latest              141fef9a2f57        14 seconds ago\nbase                   latest              b750fe79269d        12 weeks ago\nbase                   ubuntu-12.10        b750fe79269d        12 weeks ago\nbase                   ubuntu-quantl       b750fe79269d        12 weeks ago\nbase                   ubuntu-quantal      b750fe79269d        12 weeks ago\n</code></pre>\n<p>base イメージは latest, ubuntu-quantl, ubuntu-quantal, ubuntu-12.10 といった複数のタグがついていることがわかる。イメージは複数の名称をタグ付けできるようになっており、<code>base:latest</code>, <code>base:ubuntu-12.10</code> といった形で異なるイメージを呼び出せるようになっている。省略時は <code>base:latest</code> と同じ。</p>\n<p>pull してくるイメージは <a href=\"https://index.docker.io/\">https://index.docker.io/</a> から情報を持ってくる。コマンドラインで検索したい場合は <code>search</code> コマンドを利用する。</p>\n<pre><code>$ docker search centos\nFound 4 results matching your query (\"centos\")\nNAME                          DESCRIPTION\ncentos\nbackjlack/centos-6.4-x86_64\ncreack/centos\nmbkan/lamp                    centos with ssh, LAMP, PHPMyAdmin(root pas...\n</code></pre>\n<p>ローカルにキャッシュされたイメージを消すには <code>docker rmi &#x3C;イメージのID></code>でいい。</p>\n<p>自前で作ったイメージを <a href=\"https://index.docker.io/\">https://index.docker.io/</a>  に登録するには、あらかじめサイト上でアカウントを作っておき、 <code>docker login</code> した後に <code>docker push</code> する。イメージ名にアンダーバー使っていると <code>push</code> で失敗するのと、アップロードしたイメージを消す機能がまだなかったりするので注意。</p>\n<p>イメージの実体は <code>/var/lib/docker/graph/</code> にある。</p>\n<pre><code>$ docker images -a -notrunc\nREPOSITORY          TAG                 ID                                                                 CREATED\nbase                latest              b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\nbase                ubuntu-12.10        b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\nbase                ubuntu-quantl       b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\nbase                ubuntu-quantal      b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\n&#x3C;none>              &#x3C;none>              27cf784147099545                                                   12 weeks ago\n\n$ sudo ls -1 /var/lib/docker/graph\n141fef9a2f57e86dd6d9aa58fe9318b0d9d71d91053079842051d9738bad6e45\n27cf784147099545\nb750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\nchecksums\n:tmp:\n</code></pre>\n<p>ここで images に ID: 27cf784147099545 というのが現れた。これは何か。<code>inspect</code> を使うとイメージの詳細を表示できる。</p>\n<pre><code>$ docker inspect base\n{\n    \"id\": \"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n    \"parent\": \"27cf784147099545\",\n    \"created\": \"2013-03-23T22:24:18.818426-07:00\",\n    \"container\": \"3d67245a8d72ecf13f33dffac9f79dcdf70f75acb84d308770391510e0c23ad0\",\n    \"container_config\": {\n        \"Hostname\": \"\",\n        \"User\": \"\",\n        \"Memory\": 0,\n        \"MemorySwap\": 0,\n        \"CpuShares\": 0,\n        \"AttachStdin\": false,\n        \"AttachStdout\": false,\n        \"AttachStderr\": false,\n        \"PortSpecs\": null,\n        \"Tty\": true,\n        \"OpenStdin\": true,\n        \"StdinOnce\": false,\n        \"Env\": null,\n        \"Cmd\": [\n            \"/bin/bash\"\n        ],\n        \"Dns\": null,\n        \"Image\": \"base\",\n        \"Volumes\": null,\n        \"VolumesFrom\": \"\"\n    }\n}\n</code></pre>\n<p>ID: 27cf784147099545 は base イメージの親イメージの ID であることがわかる。イメージは差分になっているので、親のイメージが必要ということで初回実行のタイミングで base と一緒に 27cf784147099545 もダウンロードされていたのだった。</p>\n<h3>ネットワーク</h3>\n<p><code>docker run</code> 時に <code>-p</code> をつけることで、コンテナから外部にさらすポートを決められる。コンテナ側のポートはホスト側のポートに変換される際、ポート番号が変更される(49153以降になる)ので、<code>docker port &#x3C;ジョブのID> &#x3C;ポート番号></code> あるいは <code>docker ps </code> でポートの対応状況を確認する必要がある。</p>\n<p>ドキュメントの <a href=\"https://github.com/dotcloud/docker#expose-a-service-on-a-tcp-port\">Expose a service on a TCP port</a> がわかりやすい。</p>\n<pre><code># 以下、コメントは書き換えてある\n# また、途中経過がわかりやすいように set -x しておく\nset -x\n\n# 4444 を晒すよう -p オプションをつけて docker run しつつ、\n# コンテナは netcat で4444を待ち受ける\nJOB=$(docker run -d -p 4444 base /bin/nc -l -p 4444)\n++ docker run -d -p 4444 base /bin/nc -l -p 4444\n+ JOB=c86c892574f7\n\n# 4444 がローカルのどのポートに対応するのか確認\n# docker ps でも調べることはできる\nPORT=$(docker port $JOB 4444)\n++ docker port c86c892574f7 4444\n+ PORT=49166\n\n# ルーティングによっては localhost とか 127.0.0.1 だと\n# うまくいかないことがあるので、eth0 のIPアドレスを使おう、\n# ってことらしい\nIP=$(ifconfig eth0 | perl -n -e 'if (m/inet addr:([\\d\\.]+)/g) { print $1 }')\n++ perl -n -e 'if (m/inet addr:([\\d\\.]+)/g) { print $1 }'\n++ ifconfig eth0\n+ IP=10.156.137.111\necho hello world | nc $IP $PORT\n+ nc 10.156.137.111 49166\n+ echo hello world\n\n# コンテナが受信したメッセージを logs で表示\necho \"Daemon received: $(docker logs $JOB)\"\n++ docker logs c86c892574f7\n+ echo 'Daemon received: hello world'\nDaemon received: hello world\n</code></pre>\n<h3>Dockerfile</h3>\n<p>DSLで書かれた設定(通常ファイル名は<code>Dockerfile</code>とする)をあらかじめ用意することで、手順に従ってイメージを作ることができる。</p>\n<pre><code>読み込ませ方 (1)\ndocker build &#x3C;Dockerfileのあるディレクトリ>\n# ex. docker build .\n\n読み込ませ方 (2)\ndocker build -\n# ex. docker build - &#x3C; /foo/bar/Dockerfile\n</code></pre>\n<p>Dockerfile の例</p>\n<pre><code>FROM base\nRUN /bin/echo hi\n</code></pre>\n<p>これで、<code>docker build</code> すれば <code>docker run base /bin/echo hi</code> と同じ効果が得られる。</p>\n<p>指定できるはコマンドは以下の通り。大文字小文字は区別しないけど、引数と見分けやすいように大文字が使われる。</p>\n<ul>\n<li><code>FROM &#x3C;image></code> ベースとなるイメージを指定</li>\n<li><code>MAINTAINER &#x3C;name></code> メンテナの名前を指定</li>\n<li><code>RUN &#x3C;command></code> ビルド中に実行したいコマンドを指定</li>\n<li><code>CMD &#x3C;command></code> 起動後のコンテナで実行したいコマンドを指定</li>\n<li><code>EXPOSE &#x3C;port> [&#x3C;port> ...]</code> 外部に晒すポートの指定</li>\n<li><code>ENV &#x3C;key> &#x3C;value></code> 環境変数の設定</li>\n<li><code>INSERT &#x3C;file url> &#x3C;path></code> deprecated なので ADD を利用すること</li>\n<li><code>ADD &#x3C;src> &#x3C;dest></code> ファイルを配置</li>\n</ul>\n<p><code>RUN</code> と <code>CMD</code> の違いがわかりにくいかもしれない。例を出す。</p>\n<pre><code># RUN, CMD で指定したコマンドが実行されたとき、\n# 標準出力と /tmp/*.log に記録を残す\n\n$ cat &#x3C;&#x3C;SCRIPT >Dockerfile\n> FROM base\n> RUN /bin/echo run | tee /tmp/run.log\n> CMD /bin/echo cmd | tee /tmp/cmd.log\n> SCRIPT\n\n# ビルドの実行\n\n$ docker build .\nCaching Context 10240/? (n/a)\nFROM base ()\n===> b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\nRUN /bin/echo run | tee /tmp/run.log (b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc)\n===> d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d\nCMD /bin/echo cmd | tee /tmp/cmd.log (d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d)\n===> 60671e9969185841032fb02f623917672c4f871a6be68e5aa575e8fdf1f94229\nBuild successful.\n===> 60671e9969185841032fb02f623917672c4f871a6be68e5aa575e8fdf1f94229\n\n# run, cmd の実行結果を確認\n# => run だけが実行されている\n\n$ docker run 60671e99691 /bin/ls /tmp/\nrun.log\n\n# イメージを inspect する\n# => どうやらコンテナは記憶していることがわかる\n\n$ docker inspect 60671e99691\n{\n    \"id\": \"60671e9969185841032fb02f623917672c4f871a6be68e5aa575e8fdf1f94229\",\n    \"parent\": \"d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d\",\n    \"created\": \"2013-06-16T16:29:14.602237Z\",\n    \"container\": \"4c54683cec90500f329dfaad2e0856cc408483be0ae3166018121d4d4b9b3282\",\n    \"container_config\": {\n        \"Hostname\": \"78c72f8ba6ad\",\n        \"User\": \"\",\n        \"Memory\": 0,\n        \"MemorySwap\": 0,\n        \"CpuShares\": 0,\n        \"AttachStdin\": false,\n        \"AttachStdout\": false,\n        \"AttachStderr\": false,\n        \"PortSpecs\": null,\n        \"Tty\": false,\n        \"OpenStdin\": false,\n        \"StdinOnce\": false,\n        \"Env\": null,\n        \"Cmd\": [\n            \"/bin/sh\",\n            \"-c\",\n            \"#(nop) CMD [/bin/sh -c /bin/echo cmd | tee /tmp/cmd.log]\"\n        ],\n        \"Dns\": null,\n        \"Image\": \"d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d\",\n        \"Volumes\": null,\n\n# 引数でコマンドを指定せずに run を実行\n# => cmd で登録した内容が実行される\n\n$ docker run 60671e99691\ncmd\n</code></pre>\n<p>つまり、<code>RUN</code> は <code>Dockerfile</code> を元にビルドしているときに参照され、<code>CMD</code> はコンテナを実行する際に参照されるということがわかる。パッケージをインストールしたりといった用途では通常 <code>RUN</code> を使う。</p>\n<h2>まとめ</h2>\n<p>仮想環境の発達でプログラマブルなインフラストラクチャーは実現できてきているけど、マシンを上げたり下げたりするのにどうしても時間がかかるし、それは仕方が無いものと我慢していた。<code>Docker</code> を使ってみると、今までのそういった不満から解放されることができそう。一応開発中というステータスなのでプロダクション環境では使いづらいけど、開発やテスト、とくに構成管理ツールを設定するときなどは、この俊敏性、柔軟性は有効になると思う。</p>\n<h2>参考</h2>\n<ul>\n<li><a href=\"http://docs.docker.io/en/latest/\">Documentation</a></li>\n</ul>\n"}},"__N_SSG":true}