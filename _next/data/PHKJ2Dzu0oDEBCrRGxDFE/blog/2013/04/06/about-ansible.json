{"pageProps":{"post":{"localPath":"/home/f440/go/src/github.com/f440/f440.github.com/content/2013-04-06-about-ansible.markdown","path":"2013/04/06/about-ansible","layout":"post","title":"構成管理ツール Ansible について","createdAt":"2013-04-06T05:50:00.000Z","kind":"article","comments":true,"tags":["cm"],"content":"<p><a href=\"http://ansible.cc/\">Ansible</a> というサーバーの設定を管理するツールの説明。いわゆる構成管理 (CM: Configuration Management) にカテゴライズされるもので、Puppet や Chef の親戚みたいなものと考えてもらえればだいたいあってる。</p>\n<!-- more -->\n<h2>概要</h2>\n<p>リード開発者は Michael DeHaan で、現職の AnsibleWorks の前は Redhat で <a href=\"http://cobbler.github.io/\">Cobbler</a> や <a href=\"https://fedorahosted.org/func/\">Func</a> に携わっていたり、Puppet labs でプロダクトマネージャーしたりしているという経歴の持ち主。</p>\n<p>Ansible は Python で書かれている。同じジャンルで Python 製というと <a href=\"http://saltstack.com/\">Salt</a> が有名。Chef の場合、レシピを書くためには Ruby の知識が必要となってくるけど、Ansible はどんな言語でもモジュールが書けるようになっているので、運用にあたって Python の知識は必要無い。</p>\n<p>動作の点でも Puppet や Chef などのツールとまったく異なるアプローチをしている。Puppet や Chef は、サーバーとクライアントで構成され、クライアントとなるマシンはサーバーに設定を問い合わせながら、自分自身を「あるべき状態」に収束するよう変更を加えていく。Ansible の場合、サーバー側からクライアントとなるサーバー(群)に対して直接命令を送り込み結果を得る。これは <a href=\"https://fedorahosted.org/func/\">Func</a>、<a href=\"http://capistranorb.com/\">Capistrano</a>、<a href=\"http://fabfile.org/\">Fabric</a> などに似ているが、これらのデプロイを目的としたツールにはない「何回やっても結果が同じ」(idempotence) という CM ツールらしさはちゃんと備えている。</p>\n<p>ドキュメントは12ページしかなく(ちなみに、さっき数えてみたらChefのドキュメントは2834ファイルあった) 非常に習得は簡単。サーバーを立てる必要もなく、クライアントマシンもエージェントレス、加えて短期間で学習できるので手軽感は非常に高いが、モジュール機構が強力なのできわめて実用的になっている。</p>\n<h2>基本的な概念</h2>\n<p>Ansible を理解する上で重要となる、モジュールとプレーブックについて説明する。</p>\n<h3>モジュール</h3>\n<p>クライアント内での動きはモジュールという形で定義する。</p>\n<p>パッケージのインストール、サービスの起動、ユーザーやグループの作成などの基本的なモジュールはあるが、実際には環境に合わせて不足分は自分でモジュールを作っていくことになる。</p>\n<p>モジュールは簡単に作れる。モジュールが役割を端的に言うと、以下を行うだけである。</p>\n<ul>\n<li>\n<p>標準入力でオプションを受け取る</p>\n</li>\n<li>\n<p>標準出力で実行結果を返す</p>\n<ul>\n<li>出力形式は key=value を空白でつなげたものか JSON</li>\n</ul>\n</li>\n</ul>\n<p>これができる言語であれば、シェルスクリプトでも Perl でも問題ない。</p>\n<h3>プレーブック</h3>\n<p>実際の処理では単発のモジュールでサーバーの設定が終わることはないので、モジュールの使い方をまとめたものが必要になる。Ansible では、YAML で処理をまとめたものを プレーブック (Playbook)と呼んでいる。</p>\n<p>例: Apache と PHP をインストールする (webapp.yml)</p>\n<pre><code>- hosts: webserver\n  user: vagrant\n  sudo: yes\n  tasks:\n    - name: install apache\n      action: yum pkg=httpd state=installed\n    - name: install php\n      action: yum pkg=php state=installed\n</code></pre>\n<p>例: 実行</p>\n<pre><code># ansible-playbook プレーブック名\n$ ansible-playbook webapp.yml\n</code></pre>\n<p>以上は簡単な例だが、設定ファイルを配置したり、それに併せてサービスを再起動させたりといったことも記述可能。</p>\n<p>プレーブックには以下のような内容が含まれる:</p>\n<ul>\n<li>hosts: 対象のホスト</li>\n<li>user: 実行ユーザー</li>\n<li>vars: 変数</li>\n<li>tasks: タスク</li>\n</ul>\n<p><code>vars</code> の変数は、テンプレート内で展開される。設定ファイル配置時にパラメータを変更、といった場合に利用する。</p>\n<h3>インストール</h3>\n<p>以下では、インストールから簡単なコマンドの実行までの例を挙げる。サーバー、クライアント双方で CentOS 6.4 を利用した。</p>\n<p>Ansible を動かすためには、Python 2.6 以上と Ansible のソースコードとごくわずかな Python パッケージだけあればよい。CentOS 6 であれば Python の条件は満たせているし、EPEL で Ansible のパッケージが提供されているので、<code>yum</code> でインストール可能。</p>\n<pre><code># EPEL 有効化\n$ sudo rpm -ivh http://ftp.riken.jp/Linux/fedora/epel/6/i386/epel-release-6-8.noarch.rpm\n\n# Ansible インストール\n$ sudo yum install ansible\n</code></pre>\n<p>他の Unix 系OSであれば、<code>pip install ansible</code> でいい。</p>\n<pre><code>$ sudo pip install ansible\n</code></pre>\n<p>次に、サーバーからクライアントに SSH でログインできるように調整しておく。</p>\n<pre><code># 以下のマシンを用意した。\n# それぞれホスト名でアクセスできる\n#    Ansible 実行側 ... server\n#    変更対象 ... client1, client2\n\n# server側で公開鍵認証用の鍵を作成\n$ $ ssh-keygen -t rsa\n\n# client に公開鍵を配置する\n$ ssh-copy-id client1\n$ ssh-copy-id client2\n\n# 試しにログインしてみる\n# 頻繁に実行することになるので、公開鍵にパスフレーズを\n# 設定している場合は、ssh-agent を使ってパスフレーズの\n# 入力を省略できるようにしておく。\n$ ssh client1\n$ ssh client2\n</code></pre>\n<p>今度は、対象のサーバーを設定してみよう。環境変数 <code>ANSIBLE_HOSTS</code> にあるファイルでサーバーの指定が可能。</p>\n<pre><code>$ cat &#x3C;EOD >~/target\n> [webserver]\n> client1\n> \n> [dbserver]\n> client2\n> EOD\n$ export ANSIBLE_HOSTS=~/target\n</code></pre>\n<p>設定の中で、<code>[ ]</code> によりグループを作っている。つまり「webserver グループに client1、dbserver グループに client2 が所属している」ということを表している。グループはオプションなので、単純にホスト名を羅列するだけでもいい。試しに、対象のホストを調べてみよう。</p>\n<pre><code># ansible ホストパターン --list-hosts\n\n# ホスト名を直接指定\n$ ansible client1 --list-hosts\nclient1\n\n# グループ名を指定\n$ ansible webserver --list-hosts\nclient1\n$ ansible dbserver --list-hosts\nclient2\n\n# all を指定した場合、全サーバーを列挙\n$ ansible all --list-hosts\nclient1\nclient2\n</code></pre>\n<p>これだけで準備は完了。実行してみる。</p>\n<pre><code># コマンドの書式\nansible 対象 -m モジュール名 -a オプション\n\n# 例 ping モジュール\n$ ansible all -m ping\nclient2 | success >> {\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n\nclient1 | success >> {\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n</code></pre>\n<p><code>-m</code> をつけないで、直接コマンドを実行することも可能。</p>\n<pre><code># すべてのマシンでカーネルのバージョンを取得\n$ ansible all -a 'uname -r'\nclient2 | success | rc=0 >>\n2.6.32-358.el6.x86_64\n\nclient1 | success | rc=0 >>\n2.6.32-358.el6.x86_64\n</code></pre>\n<p>プレーブックを実行したときは以下のようになる。</p>\n<pre><code># 対象は webserver というグループ(client1 が所属)に対して、\n# Apache と PHP をインストールするプレーブック、webapp.yml を実行\n# Apache はすでにインストールされていたので、\n# PHP のみインストールされることとなった\n\n$ ansible-playbook webapp.yml\n\nPLAY [webserver] *********************\n\nGATHERING FACTS *********************\nok: [client1]\n\nTASK: [install apache] *********************\nok: [client1]\n\nTASK: [install php] *********************\nchanged: [client1]\n\nPLAY RECAP *********************\nclient1                        : ok=3    changed=1    unreachable=0    failed=0\n</code></pre>\n<h2>その他</h2>\n<ul>\n<li><a href=\"https://twitter.com/mitchellh/status/319914935910027264\">Vagrant もバージョン 1.2 から Ansible でのプロビジョニングをサポート予定</a></li>\n<li>開発は活発</li>\n<li>リリース名がヴァンヘイレンの曲名 (1.0 は Eruptionだった)</li>\n<li>ロゴがださい (ML でも 90年代のデザインなんて言われている)</li>\n</ul>\n<h2>まとめ</h2>\n<p>ロゴのセンスは悪いけど、アプリケーション自体の仕組みはすごくセンスがいい。</p>\n<p>他の構成管理ツールと比べると、DSL を覚えるといった「ツールを使うまでののコスト」、ツールのためのサーバー構築・運用といった「ツールを使ってからのコスト」が軽微なので、よりやりたいことに目が向けられるのもうれしい。</p>\n<p>最近日本国内でも Chef の話題を聞くことが多いんだけど、Chef Server の運用とかオートスケールとのコンビネーションとかの情報はあまり聞かないので、たぶん割と小規模な環境でリモートサーバーの Chef-solo をキックみたいなケースが多いのかと思う。そういったところだと、Ansible のほうがふさわしいっていうことが多いんじゃないかな。</p>\n"}},"__N_SSG":true}