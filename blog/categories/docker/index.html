<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>tagged docker - aptheia.info</title><link rel="alternate" type="application/rss+xml" title="apatheia.info" href="/atom.xml"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/3c128f59c2ecef969dbc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3c128f59c2ecef969dbc.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-1a8a258926ecde76681b.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-a9acf05574b3448968f1.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d96712b144c157b4cbfa.js" defer=""></script><script src="/_next/static/chunks/915-c287d7adb8a31cf4da35.js" defer=""></script><script src="/_next/static/chunks/pages/blog/categories/%5Btag%5D-c38c66d576a52b73b44b.js" defer=""></script><script src="/_next/static/DRRa5gyB7gBKf8n1UmP3L/_buildManifest.js" defer=""></script><script src="/_next/static/DRRa5gyB7gBKf8n1UmP3L/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header><div id="site-title"><h1><a href="/">apatheia.info</a></h1></div><nav><ul><li><a href="/">Home</a></li><li><a href="/atom.xml">RSS</a></li></ul></nav></header><main><article><h1>Articles tagged &#x27;<!-- -->docker<!-- -->&#x27;</h1><section style="margin-bottom:1em"><h2><a href="/blog/2016/02/22/install-dlite/">DLiteでOS X上にDockerの環境を構築する</a></h2><span>2016.02.22</span> <span><a href="/blog/categories/docker/">docker</a> </span></section><section style="margin-bottom:1em"><h2><a href="/blog/2013/06/17/docker/">仮想環境構築に docker を使う</a></h2><span>2013.06.17</span> <span><a href="/blog/categories/docker/">docker</a> </span><span><a href="/blog/categories/lxc/">lxc</a> </span></section></article></main><footer><ul><li>Link:</li><li><a href="https://twitter.com/f440">Twitter</a></li><li><a href="https://github.com/f440">Github</a></li><li><a href="https://pinbaord.in/u:f440">Pinbaord</a></li></ul></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"tag":"docker","posts":[{"localPath":"/home/f440/go/src/github.com/f440/f440.github.com/content/2016-02-22-install-dlite.markdown","path":"blog/2016/02/22/install-dlite","layout":"post","title":"DLiteでOS X上にDockerの環境を構築する","createdAt":"2016-02-22T11:54:00.000Z","updatedAt":"2016-05-08T10:12:00.000Z","kind":"article","comments":true,"tags":["docker"],"content":"\n[DLite][dlite] をインストールしたので、そのときのメモ。\n\n\u003c!-- more --\u003e\n\n## DLiteとは\n\nOS XでDockerを使えるようにやつ。内部では[xhyve](https://github.com/mist64/xhyve)を使っていて非常にコンパクト。\n\n## 作業環境\n\n- DLite 1.1.3\n- OS X El capitan 10.11.3\n\n## インストール手順\n\n    brew install dlite\n    sudo dlite install # CPUやディスクサイズなどのオプションは`-h`で確認可能\n\nおしまい。\n\n内部では以下が行われる:\n\n- `/etc/sudoers`に`dlite,nfs`コマンドをパスワードなしで`sudo`できるようにする設定を追加\n- `~/Library/LaunchAgents/local.dlite.plist`に起動設定を配置\n- `~/.dlite`に起動イメージをダウンロード\n\n## 起動\n\nTmux内で起動しようとするとエラーになるので、必ずTmux外でやること。\n\n    dlite start\n\n問題がなければ以下が加えられる:\n\n- `/var/run/docker.sock` にソケットファイルを作成\n- `/etc/hosts` にdliteへの参照を追加 (デフォルトは `local.docker`。インストール時のオプションで変更可能)\n- `/etc/exports` にDLite側のホストへのNFSマウントする設定を追加\n- `~/Library/LaunchAgents/local.dlite.plist` をロードし、自動起動するように設定\n\nうまくいっていれば、`docker -H unix://var/run/docker.sock`(`export DOCKER_HOST=unix:///var/run/docker.sock`で指定も可)でdockerが使えるようになる。\n\nもしうまくいかないようなら、`sudo dlite daemon`でコマンドラインから実行して原因を突き止める。とくに、NFS周りのコンフリクトが起きていないかを確認。\n\n## まとめ\n\nホストと仮想環境の間がシームレスにつながってcoLinuxっぽさがある。こういうすっきりしたツールは楽しい。\n\n## 追記\n\n2016-05-08: 現在はDocker for Macを利用している。osxfsでファイルシステムのイベントが連携できて便利。\n\n## 参考\n\n- [GitHub - nlf/dlite: The simplest way to use Docker on OS X][dlite]\n- [Simplifying Docker on OS X](https://blog.andyet.com/2016/01/25/easy-docker-on-osx/)\n\n[dlite]: https://github.com/nlf/dlite\n"},{"localPath":"/home/f440/go/src/github.com/f440/f440.github.com/content/2013-06-17-docker.markdown","path":"blog/2013/06/17/docker","layout":"post","title":"仮想環境構築に docker を使う","createdAt":"2013-06-17T00:13:00.000Z","kind":"article","comments":true,"tags":["docker","lxc"],"content":"\nちょっと前から [Docker][] を使っているので、その話。\n\n\u003c!-- more --\u003e\n\n## Dockr について\n\n[Docker][] は [dotcloud][] がオープンソースで公開している、コンテナ技術による仮想化ソフトウェア。\n\n以下のテクノロジーベースにしている:\n\n- [LXC](http://lxc.sourceforge.net/)\n  - [前にも書いた](/blog/2012/05/13/vps-lxc-xtradb-cluster/)。Xen とか VirtualBOX みたいにホスト内に仮想マシンを立ち上げるんじゃなくて、ホスト内の隔離された環境で仮想マシンを動かす技術。物理マシンをシミュレーションしているんじゃないってことは、VPS とか EC2 とかの仮想マシン上でも問題なく動くし、マシンを起動するプロセスが不要となるので、一瞬で使い始められるというメリットにつながっている。\n- [AUFS](http://aufs.sourceforge.net/)\n  - UnionFS(ディレクトリを重ね合わせることができる)の実装の一つ。元の仮想マシンイメージを書き換えないで、更新が発生した部分は別の場所に書き込んでいくようになっている。これにより、仮想マシンの立ち上げ時にイメージのコピーが発生しないので、すぐに使い始められる。\n\nDocker を使う前は LXC のラッパーとして取っつきにくさを緩和してくれる、とかそういうレベルだと思ったんだけど、予想はよい方向に裏切られた。\n\n[仮想マシンのイメージを可視化したもの](http://docs.docker.io/en/latest/commandline/command/images/)を見ると、まるで Git のコミットログみたいに見えると思う。実際、情報は差分で管理され、履歴を残したり分岐させたりといった操作が非常に軽量にできていて、Git を操作するかのように仮想マシンを操作できるようになっている。\n\n\n## 動かし方\n\nArch Linux や Debian で動かしている人がいるみたいだけど、公式サポートは今のところ Ubuntu のみ。Ubuntu 12.04 LTS を使っているのであれば、`curl get.docker.io | sh -x` で動くようになる。\n\nちゃんとしたやり方は [ドキュメント](http://docs.docker.io/en/latest/installation/)を見れば、特にはまることもないと思う。できるだけ新しい Ubuntu を使っておけばいい。\n\nすぐに試してみたいんなら、Vagrant 経由で簡単に使い始められる。\n\n    git clone https://github.com/dotcloud/docker.git\n    cd docker\n    vagrant up --provider virtualbox # or vagrant up --provider aws\n\n\n## 基礎的な操作方法\n\nインストールがうまくいって Docker が起動しているものとして、早速使ってみる。\n\n    $ docker\n    Usage: docker [OPTIONS] COMMAND [arg...]\n      -H=\"127.0.0.1:4243\": Host:port to bind/connect to\n\n      A self-sufficient runtime for linux containers.\n\n      Commands:\n      attach    Attach to a running container\n      build     Build a container from a Dockerfile\n      commit    Create a new image from a container's changes\n    (以下省略)\n\nコマンドがずらっと表示されるかと思う。まずは単発のコマンドをコンテナ内で実行してみる。\n\n    $ docker run base /bin/echo hi\n    Pulling repository base from https://index.docker.io/v1\n    Pulling image b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc (latest) from base\n    Pulling b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc metadata\n    Pulling b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc fs layer\n    Downloading 10240/? (n/a)\n    Pulling 27cf784147099545 metadata\n    Pulling 27cf784147099545 fs layer\n    Downloading 94863360/? (n/a)\n    Pulling image 27cf784147099545 () from base\n    hi\n\n「`docker` コマンドに run サブコマンドを指定して、`base` という仮想マシンで `/bin/echo hi` コマンドを実行する」という意味になる。仮想マシンがダウンロードされるが、これは初回実行時のみ。最後に表示された「hi」というのが今回の実行結果で、このコンテナの役割はこれで終わり。\n\n今度は作ったマシンの中に入ってみるために、`-i` と `-t` オプションで入出力できるようにして `/bin/bash` を起動してみる。\n\n    $ docker run -i -t base /bin/bash\n    root@bc43a290f0ce:/#\n\n端末から抜けるとホスト側に制御が戻る。\n\n    root@bc43a290f0ce:/# exit\n    exit\n    $\n\n今度は `-d` オプションでコマンドを実行しっぱなしにする。\n\n    $ docker run -i -t -d base /bin/ping -i 5 www.aikatsu.net\n    79365b2985c4\n    $\n\nID が返されて、すぐに端末が利用可能になる。稼働中のプロセスを確認してみる。\n\n    $ docker ps\n    ID                  IMAGE               COMMAND                CREATED             STATUS              PORTS\n    79365b2985c4        base:latest         /bin/ping -i 5 www.a   22 seconds ago      Up 21 seconds\n\n次に実行中の出力をのぞいてみよう。\n\n    $ docker logs 79365b2985c4\n    PING www.aikatsu.net (60.32.7.37) 56(84) bytes of data.\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=1 ttl=49 time=282 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=3 ttl=49 time=278 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=4 ttl=49 time=283 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=5 ttl=49 time=266 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=6 ttl=49 time=268 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=8 ttl=49 time=264 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=9 ttl=49 time=270 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=10 ttl=49 time=290 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=11 ttl=49 time=284 ms\n\n順調に動き続けているようなので、このジョブにアタッチしてみる。\n\n    $ docker attach 79365b2985c4\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=18 ttl=49 time=239 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=19 ttl=49 time=291 ms\n    64 bytes from www3.sunrise-anime.jp (60.32.7.37): icmp_req=20 ttl=49 time=275 ms\n    (出力が続く)\n\nアタッチ中の端末は `Ctrl-p Ctrl-q` でデタッチできる。(このとき use of closed network connection っていうエラーが出る場合 Ctrl-c で抜けるしかないっぽい。バグレポートは上がっているので、じきに直ると思う。)\n\n最後に`kill`でこのプロセスを消してみる。\n\n    $ docker kill 79365b2985c4\n    $ docker ps\n    $\n\n`ps`からプロセスが消えた。基礎的なコンテナの操作の説明は以上。\n\n## 詳細\n\n### コンテナ\n\nこれまでコマンドを実行したり、`kill` されたコンテナはどうなっているのか。実は全部残っている。停止したコンテナを表示するために`-a`をつける。ついでに、情報を省略しないで表示するために`-notrunc` もつける。\n\n    $ docker ps -a -notrunc\n    ID                                                                 IMAGE               COMMAND                          CREATED             STATUS              PORTS\n    79365b2985c43a2a6977764f4dde2d375084020fbc04cc855508c417a36f88c2   base:latest         /bin/ping -i 5 www.aikatsu.net   14 minutes ago      Exit 0\n    bc43a290f0ced4677ee7eb1a0d662cca496cc720d8db20e746dda45e4659f503   base:latest         /bin/bash                        16 minutes ago      Exit 0\n    7a666192cca72cea81cade398b22700c982fbb9271a7eca23ff51c6c504d5971   base:latest         /bin/echo hi                     16 minutes ago      Exit 0\n    8b0af4fc390d762c33dadc1b149516ba95bdb70d093e991ec2df563817f55ffb   base:latest         /bin/bash                        21 minutes ago      Exit 0\n    4637bc6341706c25e066c5ccfe92e10c923bfe4955a9e8b3ce07237fda0fb34a   base:latest         /bin/echo hi                     21 minutes ago      Exit 0\n\n正常終了しているので、すべて`Exit 0`になっている。また、ID は省略表記されていたこともわかる。コンテナの実体は `/var/lib/docker/containers/\u003cID\u003e` 以下に格納されている。\n\n    $ sudo ls /var/lib/docker/containers/\n    4637bc6341706c25e066c5ccfe92e10c923bfe4955a9e8b3ce07237fda0fb34a\n    79365b2985c43a2a6977764f4dde2d375084020fbc04cc855508c417a36f88c2\n    7a666192cca72cea81cade398b22700c982fbb9271a7eca23ff51c6c504d5971\n    8b0af4fc390d762c33dadc1b149516ba95bdb70d093e991ec2df563817f55ffb\n    bc43a290f0ced4677ee7eb1a0d662cca496cc720d8db20e746dda45e4659f503\n\nどんどんたまっていくから心配かもしれないけど、各コンテナはベースイメージからの差分しかもたないので、問題にならない。もし、消したくなったら `docker rm \u003cコンテナのID\u003e` で消せる。\n\n作業領域であったコンテナを `commit` するとイメージとして使い回せるようになる。`ユーザー名/名称`にするのが作法っぽい。\n\n    $ docker commit -m \"My first container\" 4637bc634170 f440/first_container\n    02036952e5dc\n    $ docker images\n    REPOSITORY             TAG                 ID                  CREATED\n    base                   latest              b750fe79269d        12 weeks ago\n    base                   ubuntu-quantl       b750fe79269d        12 weeks ago\n    base                   ubuntu-quantal      b750fe79269d        12 weeks ago\n    base                   ubuntu-12.10        b750fe79269d        12 weeks ago\n    f440/first_container   latest              02036952e5dc        3 seconds ago\n\nこれで今後は `docker run f440/first_container` をベースにしたコンテナを作れるようになる。\n\n### イメージ\n\nもう一回イメージの一覧を内容を確認してみよう。\n\n    $ docker images\n    REPOSITORY             TAG                 ID                  CREATED\n    f440/first-container   latest              141fef9a2f57        14 seconds ago\n    base                   latest              b750fe79269d        12 weeks ago\n    base                   ubuntu-12.10        b750fe79269d        12 weeks ago\n    base                   ubuntu-quantl       b750fe79269d        12 weeks ago\n    base                   ubuntu-quantal      b750fe79269d        12 weeks ago\n\nbase イメージは latest, ubuntu-quantl, ubuntu-quantal, ubuntu-12.10 といった複数のタグがついていることがわかる。イメージは複数の名称をタグ付けできるようになっており、`base:latest`, `base:ubuntu-12.10` といった形で異なるイメージを呼び出せるようになっている。省略時は `base:latest` と同じ。\n\npull してくるイメージは [https://index.docker.io/](https://index.docker.io/) から情報を持ってくる。コマンドラインで検索したい場合は `search` コマンドを利用する。\n\n    $ docker search centos\n    Found 4 results matching your query (\"centos\")\n    NAME                          DESCRIPTION\n    centos\n    backjlack/centos-6.4-x86_64\n    creack/centos\n    mbkan/lamp                    centos with ssh, LAMP, PHPMyAdmin(root pas...\n\nローカルにキャッシュされたイメージを消すには `docker rmi \u003cイメージのID\u003e`でいい。\n\n自前で作ったイメージを [https://index.docker.io/](https://index.docker.io/)  に登録するには、あらかじめサイト上でアカウントを作っておき、 `docker login` した後に `docker push` する。イメージ名にアンダーバー使っていると `push` で失敗するのと、アップロードしたイメージを消す機能がまだなかったりするので注意。\n\nイメージの実体は `/var/lib/docker/graph/` にある。\n\n    $ docker images -a -notrunc\n    REPOSITORY          TAG                 ID                                                                 CREATED\n    base                latest              b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\n    base                ubuntu-12.10        b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\n    base                ubuntu-quantl       b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\n    base                ubuntu-quantal      b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc   12 weeks ago\n    \u003cnone\u003e              \u003cnone\u003e              27cf784147099545                                                   12 weeks ago\n\n    $ sudo ls -1 /var/lib/docker/graph\n    141fef9a2f57e86dd6d9aa58fe9318b0d9d71d91053079842051d9738bad6e45\n    27cf784147099545\n    b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\n    checksums\n    :tmp:\n\nここで images に ID: 27cf784147099545 というのが現れた。これは何か。`inspect` を使うとイメージの詳細を表示できる。\n\n    $ docker inspect base\n    {\n        \"id\": \"b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\",\n        \"parent\": \"27cf784147099545\",\n        \"created\": \"2013-03-23T22:24:18.818426-07:00\",\n        \"container\": \"3d67245a8d72ecf13f33dffac9f79dcdf70f75acb84d308770391510e0c23ad0\",\n        \"container_config\": {\n            \"Hostname\": \"\",\n            \"User\": \"\",\n            \"Memory\": 0,\n            \"MemorySwap\": 0,\n            \"CpuShares\": 0,\n            \"AttachStdin\": false,\n            \"AttachStdout\": false,\n            \"AttachStderr\": false,\n            \"PortSpecs\": null,\n            \"Tty\": true,\n            \"OpenStdin\": true,\n            \"StdinOnce\": false,\n            \"Env\": null,\n            \"Cmd\": [\n                \"/bin/bash\"\n            ],\n            \"Dns\": null,\n            \"Image\": \"base\",\n            \"Volumes\": null,\n            \"VolumesFrom\": \"\"\n        }\n    }\n\nID: 27cf784147099545 は base イメージの親イメージの ID であることがわかる。イメージは差分になっているので、親のイメージが必要ということで初回実行のタイミングで base と一緒に 27cf784147099545 もダウンロードされていたのだった。\n\n### ネットワーク\n\n`docker run` 時に `-p` をつけることで、コンテナから外部にさらすポートを決められる。コンテナ側のポートはホスト側のポートに変換される際、ポート番号が変更される(49153以降になる)ので、`docker port \u003cジョブのID\u003e \u003cポート番号\u003e` あるいは `docker ps ` でポートの対応状況を確認する必要がある。\n\nドキュメントの [Expose a service on a TCP port](https://github.com/dotcloud/docker#expose-a-service-on-a-tcp-port) がわかりやすい。\n\n    # 以下、コメントは書き換えてある\n    # また、途中経過がわかりやすいように set -x しておく\n    set -x\n\n    # 4444 を晒すよう -p オプションをつけて docker run しつつ、\n    # コンテナは netcat で4444を待ち受ける\n    JOB=$(docker run -d -p 4444 base /bin/nc -l -p 4444)\n    ++ docker run -d -p 4444 base /bin/nc -l -p 4444\n    + JOB=c86c892574f7\n\n    # 4444 がローカルのどのポートに対応するのか確認\n    # docker ps でも調べることはできる\n    PORT=$(docker port $JOB 4444)\n    ++ docker port c86c892574f7 4444\n    + PORT=49166\n\n    # ルーティングによっては localhost とか 127.0.0.1 だと\n    # うまくいかないことがあるので、eth0 のIPアドレスを使おう、\n    # ってことらしい\n    IP=$(ifconfig eth0 | perl -n -e 'if (m/inet addr:([\\d\\.]+)/g) { print $1 }')\n    ++ perl -n -e 'if (m/inet addr:([\\d\\.]+)/g) { print $1 }'\n    ++ ifconfig eth0\n    + IP=10.156.137.111\n    echo hello world | nc $IP $PORT\n    + nc 10.156.137.111 49166\n    + echo hello world\n\n    # コンテナが受信したメッセージを logs で表示\n    echo \"Daemon received: $(docker logs $JOB)\"\n    ++ docker logs c86c892574f7\n    + echo 'Daemon received: hello world'\n    Daemon received: hello world\n\n### Dockerfile\n\nDSLで書かれた設定(通常ファイル名は`Dockerfile`とする)をあらかじめ用意することで、手順に従ってイメージを作ることができる。\n\n    読み込ませ方 (1)\n    docker build \u003cDockerfileのあるディレクトリ\u003e\n    # ex. docker build .\n\n    読み込ませ方 (2)\n    docker build -\n    # ex. docker build - \u003c /foo/bar/Dockerfile\n\nDockerfile の例\n\n    FROM base\n    RUN /bin/echo hi\n\nこれで、`docker build` すれば `docker run base /bin/echo hi` と同じ効果が得られる。\n\n指定できるはコマンドは以下の通り。大文字小文字は区別しないけど、引数と見分けやすいように大文字が使われる。\n\n- `FROM \u003cimage\u003e` ベースとなるイメージを指定\n- `MAINTAINER \u003cname\u003e` メンテナの名前を指定\n- `RUN \u003ccommand\u003e` ビルド中に実行したいコマンドを指定\n- `CMD \u003ccommand\u003e` 起動後のコンテナで実行したいコマンドを指定\n- `EXPOSE \u003cport\u003e [\u003cport\u003e ...]` 外部に晒すポートの指定\n- `ENV \u003ckey\u003e \u003cvalue\u003e` 環境変数の設定\n- `INSERT \u003cfile url\u003e \u003cpath\u003e` deprecated なので ADD を利用すること\n- `ADD \u003csrc\u003e \u003cdest\u003e` ファイルを配置\n\n`RUN` と `CMD` の違いがわかりにくいかもしれない。例を出す。\n\n    # RUN, CMD で指定したコマンドが実行されたとき、\n    # 標準出力と /tmp/*.log に記録を残す\n\n    $ cat \u003c\u003cSCRIPT \u003eDockerfile\n    \u003e FROM base\n    \u003e RUN /bin/echo run | tee /tmp/run.log\n    \u003e CMD /bin/echo cmd | tee /tmp/cmd.log\n    \u003e SCRIPT\n\n    # ビルドの実行\n\n    $ docker build .\n    Caching Context 10240/? (n/a)\n    FROM base ()\n    ===\u003e b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc\n    RUN /bin/echo run | tee /tmp/run.log (b750fe79269d2ec9a3c593ef05b4332b1d1a02a62b4accb2c21d589ff2f5f2dc)\n    ===\u003e d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d\n    CMD /bin/echo cmd | tee /tmp/cmd.log (d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d)\n    ===\u003e 60671e9969185841032fb02f623917672c4f871a6be68e5aa575e8fdf1f94229\n    Build successful.\n    ===\u003e 60671e9969185841032fb02f623917672c4f871a6be68e5aa575e8fdf1f94229\n\n    # run, cmd の実行結果を確認\n    # =\u003e run だけが実行されている\n\n    $ docker run 60671e99691 /bin/ls /tmp/\n    run.log\n\n    # イメージを inspect する\n    # =\u003e どうやらコンテナは記憶していることがわかる\n\n    $ docker inspect 60671e99691\n    {\n        \"id\": \"60671e9969185841032fb02f623917672c4f871a6be68e5aa575e8fdf1f94229\",\n        \"parent\": \"d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d\",\n        \"created\": \"2013-06-16T16:29:14.602237Z\",\n        \"container\": \"4c54683cec90500f329dfaad2e0856cc408483be0ae3166018121d4d4b9b3282\",\n        \"container_config\": {\n            \"Hostname\": \"78c72f8ba6ad\",\n            \"User\": \"\",\n            \"Memory\": 0,\n            \"MemorySwap\": 0,\n            \"CpuShares\": 0,\n            \"AttachStdin\": false,\n            \"AttachStdout\": false,\n            \"AttachStderr\": false,\n            \"PortSpecs\": null,\n            \"Tty\": false,\n            \"OpenStdin\": false,\n            \"StdinOnce\": false,\n            \"Env\": null,\n            \"Cmd\": [\n                \"/bin/sh\",\n                \"-c\",\n                \"#(nop) CMD [/bin/sh -c /bin/echo cmd | tee /tmp/cmd.log]\"\n            ],\n            \"Dns\": null,\n            \"Image\": \"d10b6bd1321d45b0228b5741c01d1f76fd0288052e56836609f9bdf217854f3d\",\n            \"Volumes\": null,\n\n    # 引数でコマンドを指定せずに run を実行\n    # =\u003e cmd で登録した内容が実行される\n\n    $ docker run 60671e99691\n    cmd\n\nつまり、`RUN` は `Dockerfile` を元にビルドしているときに参照され、`CMD` はコンテナを実行する際に参照されるということがわかる。パッケージをインストールしたりといった用途では通常 `RUN` を使う。\n\n## まとめ\n\n仮想環境の発達でプログラマブルなインフラストラクチャーは実現できてきているけど、マシンを上げたり下げたりするのにどうしても時間がかかるし、それは仕方が無いものと我慢していた。`Docker` を使ってみると、今までのそういった不満から解放されることができそう。一応開発中というステータスなのでプロダクション環境では使いづらいけど、開発やテスト、とくに構成管理ツールを設定するときなどは、この俊敏性、柔軟性は有効になると思う。\n\n## 参考\n\n- [Documentation](http://docs.docker.io/en/latest/)\n\n\n[dotCloud]: https://www.dotcloud.com/\n[Docker]: http://www.docker.io/\n"}]},"__N_SSG":true},"page":"/blog/categories/[tag]","query":{"tag":"docker"},"buildId":"DRRa5gyB7gBKf8n1UmP3L","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>