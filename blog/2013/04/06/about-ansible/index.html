<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>構成管理ツール Ansible について - aptheia.info</title><link rel="alternate" type="application/rss+xml" title="apatheia.info" href="/atom.xml"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/3c128f59c2ecef969dbc.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3c128f59c2ecef969dbc.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-a40ef1678bae11e696dba45124eadd70.js"></script><script src="/_next/static/chunks/webpack-1a8a258926ecde76681b.js" defer=""></script><script src="/_next/static/chunks/framework-895f067827ebe11ffe45.js" defer=""></script><script src="/_next/static/chunks/main-a9acf05574b3448968f1.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d96712b144c157b4cbfa.js" defer=""></script><script src="/_next/static/chunks/915-c287d7adb8a31cf4da35.js" defer=""></script><script src="/_next/static/chunks/pages/blog/%5B...slug%5D-c134caf83809c687960e.js" defer=""></script><script src="/_next/static/PHKJ2Dzu0oDEBCrRGxDFE/_buildManifest.js" defer=""></script><script src="/_next/static/PHKJ2Dzu0oDEBCrRGxDFE/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header><div id="site-title"><h1><a href="/">apatheia.info</a></h1></div><nav><ul><li><a href="/">Home</a></li><li><a href="/atom.xml">RSS</a></li></ul></nav></header><main><article><h1>構成管理ツール Ansible について</h1><p id="article-info">Published on <!-- -->2013.04.06<!-- --> <span><a href="/blog/categories/cm/">cm</a> </span></p><div><p><a href="http://ansible.cc/">Ansible</a> というサーバーの設定を管理するツールの説明。いわゆる構成管理 (CM: Configuration Management) にカテゴライズされるもので、Puppet や Chef の親戚みたいなものと考えてもらえればだいたいあってる。</p>
<!-- more -->
<h2>概要</h2>
<p>リード開発者は Michael DeHaan で、現職の AnsibleWorks の前は Redhat で <a href="http://cobbler.github.io/">Cobbler</a> や <a href="https://fedorahosted.org/func/">Func</a> に携わっていたり、Puppet labs でプロダクトマネージャーしたりしているという経歴の持ち主。</p>
<p>Ansible は Python で書かれている。同じジャンルで Python 製というと <a href="http://saltstack.com/">Salt</a> が有名。Chef の場合、レシピを書くためには Ruby の知識が必要となってくるけど、Ansible はどんな言語でもモジュールが書けるようになっているので、運用にあたって Python の知識は必要無い。</p>
<p>動作の点でも Puppet や Chef などのツールとまったく異なるアプローチをしている。Puppet や Chef は、サーバーとクライアントで構成され、クライアントとなるマシンはサーバーに設定を問い合わせながら、自分自身を「あるべき状態」に収束するよう変更を加えていく。Ansible の場合、サーバー側からクライアントとなるサーバー(群)に対して直接命令を送り込み結果を得る。これは <a href="https://fedorahosted.org/func/">Func</a>、<a href="http://capistranorb.com/">Capistrano</a>、<a href="http://fabfile.org/">Fabric</a> などに似ているが、これらのデプロイを目的としたツールにはない「何回やっても結果が同じ」(idempotence) という CM ツールらしさはちゃんと備えている。</p>
<p>ドキュメントは12ページしかなく(ちなみに、さっき数えてみたらChefのドキュメントは2834ファイルあった) 非常に習得は簡単。サーバーを立てる必要もなく、クライアントマシンもエージェントレス、加えて短期間で学習できるので手軽感は非常に高いが、モジュール機構が強力なのできわめて実用的になっている。</p>
<h2>基本的な概念</h2>
<p>Ansible を理解する上で重要となる、モジュールとプレーブックについて説明する。</p>
<h3>モジュール</h3>
<p>クライアント内での動きはモジュールという形で定義する。</p>
<p>パッケージのインストール、サービスの起動、ユーザーやグループの作成などの基本的なモジュールはあるが、実際には環境に合わせて不足分は自分でモジュールを作っていくことになる。</p>
<p>モジュールは簡単に作れる。モジュールが役割を端的に言うと、以下を行うだけである。</p>
<ul>
<li>
<p>標準入力でオプションを受け取る</p>
</li>
<li>
<p>標準出力で実行結果を返す</p>
<ul>
<li>出力形式は key=value を空白でつなげたものか JSON</li>
</ul>
</li>
</ul>
<p>これができる言語であれば、シェルスクリプトでも Perl でも問題ない。</p>
<h3>プレーブック</h3>
<p>実際の処理では単発のモジュールでサーバーの設定が終わることはないので、モジュールの使い方をまとめたものが必要になる。Ansible では、YAML で処理をまとめたものを プレーブック (Playbook)と呼んでいる。</p>
<p>例: Apache と PHP をインストールする (webapp.yml)</p>
<pre><code>- hosts: webserver
  user: vagrant
  sudo: yes
  tasks:
    - name: install apache
      action: yum pkg=httpd state=installed
    - name: install php
      action: yum pkg=php state=installed
</code></pre>
<p>例: 実行</p>
<pre><code># ansible-playbook プレーブック名
$ ansible-playbook webapp.yml
</code></pre>
<p>以上は簡単な例だが、設定ファイルを配置したり、それに併せてサービスを再起動させたりといったことも記述可能。</p>
<p>プレーブックには以下のような内容が含まれる:</p>
<ul>
<li>hosts: 対象のホスト</li>
<li>user: 実行ユーザー</li>
<li>vars: 変数</li>
<li>tasks: タスク</li>
</ul>
<p><code>vars</code> の変数は、テンプレート内で展開される。設定ファイル配置時にパラメータを変更、といった場合に利用する。</p>
<h3>インストール</h3>
<p>以下では、インストールから簡単なコマンドの実行までの例を挙げる。サーバー、クライアント双方で CentOS 6.4 を利用した。</p>
<p>Ansible を動かすためには、Python 2.6 以上と Ansible のソースコードとごくわずかな Python パッケージだけあればよい。CentOS 6 であれば Python の条件は満たせているし、EPEL で Ansible のパッケージが提供されているので、<code>yum</code> でインストール可能。</p>
<pre><code># EPEL 有効化
$ sudo rpm -ivh http://ftp.riken.jp/Linux/fedora/epel/6/i386/epel-release-6-8.noarch.rpm

# Ansible インストール
$ sudo yum install ansible
</code></pre>
<p>他の Unix 系OSであれば、<code>pip install ansible</code> でいい。</p>
<pre><code>$ sudo pip install ansible
</code></pre>
<p>次に、サーバーからクライアントに SSH でログインできるように調整しておく。</p>
<pre><code># 以下のマシンを用意した。
# それぞれホスト名でアクセスできる
#    Ansible 実行側 ... server
#    変更対象 ... client1, client2

# server側で公開鍵認証用の鍵を作成
$ $ ssh-keygen -t rsa

# client に公開鍵を配置する
$ ssh-copy-id client1
$ ssh-copy-id client2

# 試しにログインしてみる
# 頻繁に実行することになるので、公開鍵にパスフレーズを
# 設定している場合は、ssh-agent を使ってパスフレーズの
# 入力を省略できるようにしておく。
$ ssh client1
$ ssh client2
</code></pre>
<p>今度は、対象のサーバーを設定してみよう。環境変数 <code>ANSIBLE_HOSTS</code> にあるファイルでサーバーの指定が可能。</p>
<pre><code>$ cat &#x3C;EOD >~/target
> [webserver]
> client1
> 
> [dbserver]
> client2
> EOD
$ export ANSIBLE_HOSTS=~/target
</code></pre>
<p>設定の中で、<code>[ ]</code> によりグループを作っている。つまり「webserver グループに client1、dbserver グループに client2 が所属している」ということを表している。グループはオプションなので、単純にホスト名を羅列するだけでもいい。試しに、対象のホストを調べてみよう。</p>
<pre><code># ansible ホストパターン --list-hosts

# ホスト名を直接指定
$ ansible client1 --list-hosts
client1

# グループ名を指定
$ ansible webserver --list-hosts
client1
$ ansible dbserver --list-hosts
client2

# all を指定した場合、全サーバーを列挙
$ ansible all --list-hosts
client1
client2
</code></pre>
<p>これだけで準備は完了。実行してみる。</p>
<pre><code># コマンドの書式
ansible 対象 -m モジュール名 -a オプション

# 例 ping モジュール
$ ansible all -m ping
client2 | success >> {
    "changed": false,
    "ping": "pong"
}

client1 | success >> {
    "changed": false,
    "ping": "pong"
}
</code></pre>
<p><code>-m</code> をつけないで、直接コマンドを実行することも可能。</p>
<pre><code># すべてのマシンでカーネルのバージョンを取得
$ ansible all -a 'uname -r'
client2 | success | rc=0 >>
2.6.32-358.el6.x86_64

client1 | success | rc=0 >>
2.6.32-358.el6.x86_64
</code></pre>
<p>プレーブックを実行したときは以下のようになる。</p>
<pre><code># 対象は webserver というグループ(client1 が所属)に対して、
# Apache と PHP をインストールするプレーブック、webapp.yml を実行
# Apache はすでにインストールされていたので、
# PHP のみインストールされることとなった

$ ansible-playbook webapp.yml

PLAY [webserver] *********************

GATHERING FACTS *********************
ok: [client1]

TASK: [install apache] *********************
ok: [client1]

TASK: [install php] *********************
changed: [client1]

PLAY RECAP *********************
client1                        : ok=3    changed=1    unreachable=0    failed=0
</code></pre>
<h2>その他</h2>
<ul>
<li><a href="https://twitter.com/mitchellh/status/319914935910027264">Vagrant もバージョン 1.2 から Ansible でのプロビジョニングをサポート予定</a></li>
<li>開発は活発</li>
<li>リリース名がヴァンヘイレンの曲名 (1.0 は Eruptionだった)</li>
<li>ロゴがださい (ML でも 90年代のデザインなんて言われている)</li>
</ul>
<h2>まとめ</h2>
<p>ロゴのセンスは悪いけど、アプリケーション自体の仕組みはすごくセンスがいい。</p>
<p>他の構成管理ツールと比べると、DSL を覚えるといった「ツールを使うまでののコスト」、ツールのためのサーバー構築・運用といった「ツールを使ってからのコスト」が軽微なので、よりやりたいことに目が向けられるのもうれしい。</p>
<p>最近日本国内でも Chef の話題を聞くことが多いんだけど、Chef Server の運用とかオートスケールとのコンビネーションとかの情報はあまり聞かないので、たぶん割と小規模な環境でリモートサーバーの Chef-solo をキックみたいなケースが多いのかと思う。そういったところだと、Ansible のほうがふさわしいっていうことが多いんじゃないかな。</p>
</div></article></main><footer><ul><li>Link:</li><li><a href="https://twitter.com/f440">Twitter</a></li><li><a href="https://github.com/f440">Github</a></li><li><a href="https://pinbaord.in/u:f440">Pinbaord</a></li></ul></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"localPath":"/home/f440/go/src/github.com/f440/f440.github.com/content/2013-04-06-about-ansible.markdown","path":"2013/04/06/about-ansible","layout":"post","title":"構成管理ツール Ansible について","createdAt":"2013-04-06T05:50:00.000Z","kind":"article","comments":true,"tags":["cm"],"content":"\u003cp\u003e\u003ca href=\"http://ansible.cc/\"\u003eAnsible\u003c/a\u003e というサーバーの設定を管理するツールの説明。いわゆる構成管理 (CM: Configuration Management) にカテゴライズされるもので、Puppet や Chef の親戚みたいなものと考えてもらえればだいたいあってる。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch2\u003e概要\u003c/h2\u003e\n\u003cp\u003eリード開発者は Michael DeHaan で、現職の AnsibleWorks の前は Redhat で \u003ca href=\"http://cobbler.github.io/\"\u003eCobbler\u003c/a\u003e や \u003ca href=\"https://fedorahosted.org/func/\"\u003eFunc\u003c/a\u003e に携わっていたり、Puppet labs でプロダクトマネージャーしたりしているという経歴の持ち主。\u003c/p\u003e\n\u003cp\u003eAnsible は Python で書かれている。同じジャンルで Python 製というと \u003ca href=\"http://saltstack.com/\"\u003eSalt\u003c/a\u003e が有名。Chef の場合、レシピを書くためには Ruby の知識が必要となってくるけど、Ansible はどんな言語でもモジュールが書けるようになっているので、運用にあたって Python の知識は必要無い。\u003c/p\u003e\n\u003cp\u003e動作の点でも Puppet や Chef などのツールとまったく異なるアプローチをしている。Puppet や Chef は、サーバーとクライアントで構成され、クライアントとなるマシンはサーバーに設定を問い合わせながら、自分自身を「あるべき状態」に収束するよう変更を加えていく。Ansible の場合、サーバー側からクライアントとなるサーバー(群)に対して直接命令を送り込み結果を得る。これは \u003ca href=\"https://fedorahosted.org/func/\"\u003eFunc\u003c/a\u003e、\u003ca href=\"http://capistranorb.com/\"\u003eCapistrano\u003c/a\u003e、\u003ca href=\"http://fabfile.org/\"\u003eFabric\u003c/a\u003e などに似ているが、これらのデプロイを目的としたツールにはない「何回やっても結果が同じ」(idempotence) という CM ツールらしさはちゃんと備えている。\u003c/p\u003e\n\u003cp\u003eドキュメントは12ページしかなく(ちなみに、さっき数えてみたらChefのドキュメントは2834ファイルあった) 非常に習得は簡単。サーバーを立てる必要もなく、クライアントマシンもエージェントレス、加えて短期間で学習できるので手軽感は非常に高いが、モジュール機構が強力なのできわめて実用的になっている。\u003c/p\u003e\n\u003ch2\u003e基本的な概念\u003c/h2\u003e\n\u003cp\u003eAnsible を理解する上で重要となる、モジュールとプレーブックについて説明する。\u003c/p\u003e\n\u003ch3\u003eモジュール\u003c/h3\u003e\n\u003cp\u003eクライアント内での動きはモジュールという形で定義する。\u003c/p\u003e\n\u003cp\u003eパッケージのインストール、サービスの起動、ユーザーやグループの作成などの基本的なモジュールはあるが、実際には環境に合わせて不足分は自分でモジュールを作っていくことになる。\u003c/p\u003e\n\u003cp\u003eモジュールは簡単に作れる。モジュールが役割を端的に言うと、以下を行うだけである。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e標準入力でオプションを受け取る\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e標準出力で実行結果を返す\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e出力形式は key=value を空白でつなげたものか JSON\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eこれができる言語であれば、シェルスクリプトでも Perl でも問題ない。\u003c/p\u003e\n\u003ch3\u003eプレーブック\u003c/h3\u003e\n\u003cp\u003e実際の処理では単発のモジュールでサーバーの設定が終わることはないので、モジュールの使い方をまとめたものが必要になる。Ansible では、YAML で処理をまとめたものを プレーブック (Playbook)と呼んでいる。\u003c/p\u003e\n\u003cp\u003e例: Apache と PHP をインストールする (webapp.yml)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e- hosts: webserver\n  user: vagrant\n  sudo: yes\n  tasks:\n    - name: install apache\n      action: yum pkg=httpd state=installed\n    - name: install php\n      action: yum pkg=php state=installed\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e例: 実行\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# ansible-playbook プレーブック名\n$ ansible-playbook webapp.yml\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以上は簡単な例だが、設定ファイルを配置したり、それに併せてサービスを再起動させたりといったことも記述可能。\u003c/p\u003e\n\u003cp\u003eプレーブックには以下のような内容が含まれる:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehosts: 対象のホスト\u003c/li\u003e\n\u003cli\u003euser: 実行ユーザー\u003c/li\u003e\n\u003cli\u003evars: 変数\u003c/li\u003e\n\u003cli\u003etasks: タスク\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003evars\u003c/code\u003e の変数は、テンプレート内で展開される。設定ファイル配置時にパラメータを変更、といった場合に利用する。\u003c/p\u003e\n\u003ch3\u003eインストール\u003c/h3\u003e\n\u003cp\u003e以下では、インストールから簡単なコマンドの実行までの例を挙げる。サーバー、クライアント双方で CentOS 6.4 を利用した。\u003c/p\u003e\n\u003cp\u003eAnsible を動かすためには、Python 2.6 以上と Ansible のソースコードとごくわずかな Python パッケージだけあればよい。CentOS 6 であれば Python の条件は満たせているし、EPEL で Ansible のパッケージが提供されているので、\u003ccode\u003eyum\u003c/code\u003e でインストール可能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# EPEL 有効化\n$ sudo rpm -ivh http://ftp.riken.jp/Linux/fedora/epel/6/i386/epel-release-6-8.noarch.rpm\n\n# Ansible インストール\n$ sudo yum install ansible\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e他の Unix 系OSであれば、\u003ccode\u003epip install ansible\u003c/code\u003e でいい。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ sudo pip install ansible\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e次に、サーバーからクライアントに SSH でログインできるように調整しておく。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 以下のマシンを用意した。\n# それぞれホスト名でアクセスできる\n#    Ansible 実行側 ... server\n#    変更対象 ... client1, client2\n\n# server側で公開鍵認証用の鍵を作成\n$ $ ssh-keygen -t rsa\n\n# client に公開鍵を配置する\n$ ssh-copy-id client1\n$ ssh-copy-id client2\n\n# 試しにログインしてみる\n# 頻繁に実行することになるので、公開鍵にパスフレーズを\n# 設定している場合は、ssh-agent を使ってパスフレーズの\n# 入力を省略できるようにしておく。\n$ ssh client1\n$ ssh client2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e今度は、対象のサーバーを設定してみよう。環境変数 \u003ccode\u003eANSIBLE_HOSTS\u003c/code\u003e にあるファイルでサーバーの指定が可能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat \u0026#x3C;EOD \u003e~/target\n\u003e [webserver]\n\u003e client1\n\u003e \n\u003e [dbserver]\n\u003e client2\n\u003e EOD\n$ export ANSIBLE_HOSTS=~/target\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e設定の中で、\u003ccode\u003e[ ]\u003c/code\u003e によりグループを作っている。つまり「webserver グループに client1、dbserver グループに client2 が所属している」ということを表している。グループはオプションなので、単純にホスト名を羅列するだけでもいい。試しに、対象のホストを調べてみよう。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# ansible ホストパターン --list-hosts\n\n# ホスト名を直接指定\n$ ansible client1 --list-hosts\nclient1\n\n# グループ名を指定\n$ ansible webserver --list-hosts\nclient1\n$ ansible dbserver --list-hosts\nclient2\n\n# all を指定した場合、全サーバーを列挙\n$ ansible all --list-hosts\nclient1\nclient2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eこれだけで準備は完了。実行してみる。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# コマンドの書式\nansible 対象 -m モジュール名 -a オプション\n\n# 例 ping モジュール\n$ ansible all -m ping\nclient2 | success \u003e\u003e {\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n\nclient1 | success \u003e\u003e {\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e-m\u003c/code\u003e をつけないで、直接コマンドを実行することも可能。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# すべてのマシンでカーネルのバージョンを取得\n$ ansible all -a 'uname -r'\nclient2 | success | rc=0 \u003e\u003e\n2.6.32-358.el6.x86_64\n\nclient1 | success | rc=0 \u003e\u003e\n2.6.32-358.el6.x86_64\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eプレーブックを実行したときは以下のようになる。\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# 対象は webserver というグループ(client1 が所属)に対して、\n# Apache と PHP をインストールするプレーブック、webapp.yml を実行\n# Apache はすでにインストールされていたので、\n# PHP のみインストールされることとなった\n\n$ ansible-playbook webapp.yml\n\nPLAY [webserver] *********************\n\nGATHERING FACTS *********************\nok: [client1]\n\nTASK: [install apache] *********************\nok: [client1]\n\nTASK: [install php] *********************\nchanged: [client1]\n\nPLAY RECAP *********************\nclient1                        : ok=3    changed=1    unreachable=0    failed=0\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eその他\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://twitter.com/mitchellh/status/319914935910027264\"\u003eVagrant もバージョン 1.2 から Ansible でのプロビジョニングをサポート予定\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e開発は活発\u003c/li\u003e\n\u003cli\u003eリリース名がヴァンヘイレンの曲名 (1.0 は Eruptionだった)\u003c/li\u003e\n\u003cli\u003eロゴがださい (ML でも 90年代のデザインなんて言われている)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eまとめ\u003c/h2\u003e\n\u003cp\u003eロゴのセンスは悪いけど、アプリケーション自体の仕組みはすごくセンスがいい。\u003c/p\u003e\n\u003cp\u003e他の構成管理ツールと比べると、DSL を覚えるといった「ツールを使うまでののコスト」、ツールのためのサーバー構築・運用といった「ツールを使ってからのコスト」が軽微なので、よりやりたいことに目が向けられるのもうれしい。\u003c/p\u003e\n\u003cp\u003e最近日本国内でも Chef の話題を聞くことが多いんだけど、Chef Server の運用とかオートスケールとのコンビネーションとかの情報はあまり聞かないので、たぶん割と小規模な環境でリモートサーバーの Chef-solo をキックみたいなケースが多いのかと思う。そういったところだと、Ansible のほうがふさわしいっていうことが多いんじゃないかな。\u003c/p\u003e\n"}},"__N_SSG":true},"page":"/blog/[...slug]","query":{"slug":["2013","04","06","about-ansible"]},"buildId":"PHKJ2Dzu0oDEBCrRGxDFE","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>